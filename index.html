<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Go Master - RobinsAI.world</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles */
        html, body {
            height: 100%; margin: 0; padding: 0;
            overflow: hidden; /* Prevent scrolling on body */
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
        }

        /* Main container fills the body */
        .main-container {
            display: flex;
            flex-direction: column; /* Stack elements vertically on small screens */
            width: 100vw; /* Take full viewport width */
            height: 100vh; /* Use viewport height */
            overflow: hidden; /* Prevent scrollbars on main container */
            padding: 1rem; /* Add padding around the edges */
            gap: 1rem; /* Space between sidebar and main area */
            box-sizing: border-box; /* Include padding and border in the element's total width and height */
        }

        /* --- Sidebar --- */
        .sidebar {
             width: 250px;
             background-color: #2d3748; /* bg-gray-800 */
             padding: 1rem; border-radius: 0.5rem;
             box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
             display: flex; flex-direction: column;
             flex-shrink: 0;
             overflow-y: auto; /* For any direct in-flow content that might make sidebar too tall */
             position: relative; /* Crucial for absolute positioning of overlays */
             order: 1; /* Sidebar first on small screens */
             min-height: 200px; /* Ensure minimum height for sidebar */
         }

        /* --- Center Area --- */
        .center-area {
            flex: 1;
            display: flex; flex-direction: column;
            align-items: center; justify-content: flex-start;
            background-color: #1f2937; /* bg-gray-900 */
            padding: 1rem; border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            min-height: 300px;
            overflow: hidden;
            order: 0; /* Content first on small screens */
        }

        /* Responsive adjustments */
        @media (max-width: 767px) {
            .main-container {
                flex-direction: column;
            }
            .sidebar {
                width: 100%;
                order: 0;
                min-height: auto;
                max-height: 250px;
            }
            .center-area {
                order: 1;
            }
            .go-board {
                width: 85vw;
                height: 85vw;
            }
        }
        
        @media (min-width: 768px) { /* Tailwind's default 'md' breakpoint */
            .main-container {
                flex-direction: row;
                align-items: flex-start;
            }
            .sidebar {
                width: 300px;
                order: 0;
                align-self: flex-start; /* Ensure sidebar aligns to top in row layout */
            }
            .center-area {
                order: 1;
            }
        }

        @media (min-width: 1024px) { /* Tailwind's default 'lg' breakpoint */
            .sidebar {
                width: 350px;
            }
        }
         #game-status {
            margin-bottom: 1rem;
            margin-top: 1rem;
            text-align: center;
            flex-shrink: 0;
            width: 100%;
         }

        /* --- Hamburger Menu Button --- */
        #menu-toggle {
            position: fixed; top: 1rem; left: 1rem;
            z-index: 30; background: #4a5568; border: none;
            padding: 0.5rem; border-radius: 0.375rem; cursor: pointer;
        }
         #menu-toggle svg { width: 1.5rem; height: 1.5rem; stroke: #e2e8f0; }

        /* --- Options Menu Overlay --- */
        #options-menu {
            position: absolute; top: 0; left: 0; right: 0; /* Position within sidebar */
            background-color: #2d3748; border: 1px solid #4a5568;
            border-radius: 0.5rem; padding: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2), 0 4px 6px -2px rgba(0, 0, 0, 0.1);
            z-index: 25;
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
            transform: translateY(-10px); opacity: 0; pointer-events: none;
            overflow-y: auto; /* Allows scrolling within the menu if content exceeds max-height */
            max-height: 100%; /* Use full sidebar height */
            box-sizing: border-box; /* Ensures padding and border are included in the element's total width and height */
        }
        #options-menu.open { transform: translateY(0); opacity: 1; pointer-events: auto; }


        /* --- In-Game Controls Container (Tray Overlay) --- */
        #in-game-controls-container {
            position: absolute;
            bottom: 1rem; /* Position at the bottom of the sidebar */
            left: 1rem;
            right: 1rem; /* Takes full width of sidebar padding */
            background-color: #2d3748;
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 -4px 10px rgba(0, 0, 0, 0.2);
            z-index: 20;
            /* No overflow-y or max-height here; its content is managed by the accordion */
        }


        /* Go Board Styles */
        /* Board container */
        .go-board {
            background-color: #d2b48c;
            border: 2px solid #8b4513;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
            aspect-ratio: 1 / 1;
            position: relative;
            width: 80vmin;
            height: 80vmin;
            max-width: 600px;
            max-height: 600px;
            margin: 0 auto;
            flex-shrink: 0;
            padding: 20px;
            cursor: pointer;
            user-select: none;
        }

        /* Layers */
        .board-lines {
            position: absolute;
            inset: 20px;
            pointer-events: none;
            z-index: 1;
        }

        .intersections-layer {
            position: absolute;
            inset: 20px;
            z-index: 10;
            pointer-events: auto !important;
            /* Debug visibility */
            background-color: rgba(255, 0, 0, 0.1);
        }

        /* Individual intersections */
        .intersection {
            position: absolute;
            width: 30px;
            height: 30px;
            transform: translate(-50%, -50%);
            z-index: 20;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer !important;
            pointer-events: auto !important;
            /* Debug visibility */
            background-color: rgba(255, 0, 0, 0.3);
            border: 2px solid rgba(255, 0, 0, 0.5);
            border-radius: 50%;
        }

        .intersection:hover {
            background-color: rgba(255, 255, 0, 0.5);
            transform: translate(-50%, -50%) scale(1.2);
            z-index: 30;
        }

        /* Debug elements */
        .debug-overlay {
            z-index: 100;
            pointer-events: none;
        }

        .debug-info {
            z-index: 100;
            background-color: rgba(0, 0, 0, 0.8);
            color: yellow;
            padding: 5px;
            font-family: monospace;
            pointer-events: none;
        }
        .line { position: absolute; background-color: #4a5568; pointer-events: none; }
        .h-line { width: 100%; height: 1px; }
        .v-line { height: 100%; width: 1px; }

        /* Intersection points */
        .intersection {
            position: absolute;
            cursor: pointer !important;
            width: 40px;  /* Larger click target */
            height: 40px;
            margin-left: -20px;  /* Center the intersection */
            margin-top: -20px;
            z-index: 15;  /* Ensure it's above everything */
            display: flex;
            justify-content: center;
            align-items: center;
            box-sizing: border-box;
            border-radius: 50%;
            background-color: rgba(255, 0, 0, 0.3);  /* Very visible for debugging */
            border: 3px solid rgba(255, 0, 0, 0.5);
            transition: all 0.2s ease;
            /* Force pointer events */
            pointer-events: auto !important;
            user-select: none;
        }

        /* Very obvious hover state */
        .intersection:hover {
            background-color: rgba(255, 215, 0, 0.8) !important;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.9);
            transform: scale(1.2);  /* Make it grow on hover */
        }

        /* Debug coordinate display */
        .intersection::before {
            content: attr(data-row) ',' attr(data-col);
            position: absolute;
            color: black;
            font-size: 10px;
            font-weight: bold;
            pointer-events: none;
        }

        .stone {
            position: absolute;
            /* width: 90%; height: 90%; left: 5%; top: 5%; */ /* These are not used when stone is child of GO_BOARD and styled by JS */
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            z-index: 2; /* Set by JS, but good to have a base */
            pointer-events: none;
        }
        .black-stone { background-color: #2d3748; border: 1px solid #1a202c; }
        .white-stone { background-color: #f7fafc; border: 1px solid #a0aec0; }

        .star-point {
            position: absolute;
            background-color: #4a5568; /* Same color as lines */
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 0; /* Below lines */
            width: 6px; /* Added dimension */
            height: 6px; /* Added dimension */
        }

        .game-button { background-color: #4a5568; color: #e2e8f0; border: 1px solid #718096; padding: 0.5rem 1rem; border-radius: 0.375rem; font-weight: 500; transition: background-color 0.2s ease-in-out, transform 0.1s ease; text-align: center; cursor: pointer; display: block; width: 100%; margin-bottom: 0.5rem; }
        .game-button:hover { background-color: #718096; }
        .game-button:active { transform: scale(0.98); }
        .game-button:disabled { background-color: #2d3748; color: #718096; cursor: not-allowed; border-color: #4a5568; }

        /* --- MODAL STYLES --- */
        .modal {
            display: none; /* Hidden by default */
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.6);
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }
        .modal-content {
            background-color: #2d3748;
            padding: 2rem;
            border: 1px solid #4a5568;
            width: 90%;
            max-width: 500px;
            border-radius: 0.5rem;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            color: #e2e8f0;
            position: relative;
        }
        .modal-close {
            color: #a0aec0;
            position: absolute;
            top: 0.5rem;
            right: 0.75rem;
            font-size: 1.75rem;
            font-weight: bold;
            line-height: 1;
            cursor: pointer;
            transition: color 0.2s ease;
        }
        .modal-close:hover,
        .modal-close:focus {
            color: #e2e8f0;
            text-decoration: none;
        }

        .text-input { background-color: #4a5568; border: 1px solid #718096; color: #e2e8f0; padding: 0.5rem; border-radius: 0.375rem; width: 100%; margin-top: 0.5rem; margin-bottom: 1rem; }
        .text-input:focus { outline: none; border-color: #a0aec0; box-shadow: 0 0 0 2px rgba(160, 174, 192, 0.5); }

        .tutorial-card { background-color: #4a5568; border: 1px solid #718096; padding: 1rem; border-radius: 0.375rem; margin-bottom: 1rem; }
        .coord-label {
            position: absolute;
            font-size: 0.65rem;
            color: rgba(45, 55, 72, 0.7);
            pointer-events: none;
            line-height: 1;
            z-index: 3; /* Raised to be above lines (1) and stones (2) */
        }

        /* Accordion toggle for in-game controls (content within the tray) */
         .ingame-controls-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.75rem;
            cursor: pointer;
        }
        .ingame-controls-toggle-button {
            background-color: transparent; border: none; color: #a0aec0;
            padding: 0.25rem;
            cursor: pointer;
            transition: color 0.2s ease;
        }
        .ingame-controls-toggle-button:hover { color: #e2e8f0; }
        .ingame-controls-toggle-button svg { width: 1rem; height: 1rem; transition: transform 0.2s ease-in-out; }
        .ingame-controls-toggle-button.collapsed svg { transform: rotate(-90deg); }


        /* Hint visual style */
        .hint-visual {
            position: absolute; border-radius: 50%;
            background-color: rgba(255, 255, 0, 0.35);
            pointer-events: none;
            z-index: 3;
            border: 1px dashed rgba(255, 200, 0, 0.7);
            box-shadow: 0 0 8px rgba(255, 255, 0, 0.5);
        }
        /* Glowing halo on hover for intersections */
        .intersection:hover::after {
            content: "";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            /* Use fixed size instead of percentage for consistent halo */
            width: 20px;
            height: 20px;
            border-radius: 50%;
            box-shadow: 0 0 15px 5px rgba(255, 215, 0, 0.8);
            pointer-events: none;
            animation: pulse 0.2s ease-in-out;
        }
        /* Pulse animation for halo */
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
        /* Ripple animation for stone placement */
        @keyframes ripple {
            from { transform: scale(0); opacity: 0.8; }
            to { transform: scale(2); opacity: 0; }
        }
        .stone-ripple {
            position: absolute;
            border: 2px solid rgba(255, 215, 0, 0.9);
            border-radius: 50%;
            animation: ripple 0.6s ease-out;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <audio id="hoverSound" src="https://assets.mixkit.co/sfx/preview/mixkit-game-treasure-coin-2038.mp3" preload="auto"></audio>

    <button id="menu-toggle" aria-label="Toggle Menu">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5" />
        </svg>
    </button>

    <div class="main-container">

        <div class="sidebar">
            <div id="options-menu">
                <h2 class="text-lg font-semibold mb-3 text-white">Game Options</h2>
                <div id="game-options-menu-content" class="space-y-2 mb-4">
                     <select id="board-size-select" class="game-button bg-gray-700 text-white p-2 rounded w-full mb-2">
                         <option value="9">9x9 Board</option>
                         <option value="13">13x13 Board</option>
                         <option value="19">19x19 Board</option>
                     </select>
                    <button id="new-game-pvp" class="game-button">New Game (PvP)</button>
                    <button id="new-game-pvc" class="game-button">New Game (vs AI)</button>
                    <button id="save-game" class="game-button" disabled>Save Game</button>
                    <button id="load-game" class="game-button">Load Game</button>
                    <button id="host-game" class="game-button" disabled>Host Game (PvP)</button>
                    <button id="join-game" class="game-button">Join Game (PvP)</button>
                </div>
                 <hr class="border-gray-600 my-4">
                 <div id="utility-menu-content" class="space-y-2">
                     <button id="tutorial-button" class="game-button">Tutorial</button>
                     <button id="about-button" class="game-button">About</button>
                     <button id="settings-button" class="game-button">Settings</button>
                 </div>
            </div>

             <div id="in-game-controls-container" class="hidden">
                 <div id="ingame-controls-header" class="ingame-controls-header"> <h2 id="ingame-title" class="text-lg font-semibold text-white">In-Game</h2>
                    <button id="ingame-controls-toggle-btn" class="ingame-controls-toggle-button" aria-label="Toggle In-Game Controls">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
                        </svg>
                    </button>
                 </div>
                 <div id="in-game-controls" class="space-y-2"> <button id="pass-turn" class="game-button">Pass Turn</button>
                     <button id="resign-game" class="game-button bg-red-700 hover:bg-red-600">Resign</button>
                     <button id="get-hint" class="game-button" disabled>Get Hint (AI Only)</button>
                     <button id="toggle-coordinates" class="game-button">Toggle Coords</button>
                 </div>
             </div>
        </div>

        <div class="center-area">
            <div id="game-status">
                <p id="turn-indicator" class="text-xl font-semibold">Click board to start vs AI</p> <p id="capture-info" class="text-sm text-gray-400">Black Captures: 0 | White Captures: 0</p>
                <p id="message-area" class="text-yellow-400 mt-2 h-6"></p>
            </div>
            <div id="go-board" class="go-board" data-debug="board"
                 onclick="console.log('DEBUG Board click:', event); event.stopPropagation(); return true;"
                 onmousemove="this.querySelector('.debug-info').textContent = `Mouse: ${event.clientX}, ${event.clientY}`">
               <div class="board-lines" data-debug="lines"></div>
               <div class="debug-overlay" style="position: absolute; inset: 0; border: 2px solid yellow; pointer-events: none; z-index: 100;" data-debug="overlay"></div>
               <div class="debug-center" style="position: absolute; top: 50%; left: 50%; width: 10px; height: 10px; background: yellow; transform: translate(-50%, -50%); pointer-events: none; z-index: 100;" data-debug="center"></div>
               <div class="debug-info" style="position: absolute; bottom: 0; left: 0; background: rgba(0,0,0,0.8); color: yellow; padding: 5px; font-size: 12px; pointer-events: none; z-index: 100;" data-debug="info">Click to test</div>
               <div class="intersections-layer" style="position: absolute; inset: 0; z-index: 10;" data-debug="intersections-layer" onclick="console.log('DEBUG Layer click:', event);"></div>
           </div>
        </div>

    </div>

    <div id="save-load-modal" class="modal"> <div class="modal-content"> <span class="modal-close" onclick="closeModal('save-load-modal')">&times;</span> <h2 id="save-load-title" class="text-xl font-semibold mb-4">Load Game</h2> <div id="saved-games-list"> <p class="text-gray-400">No saved games found.</p> </div> <input type="text" id="save-name-input" placeholder="Enter save name (optional)" class="text-input mt-4 hidden"> <button id="confirm-save-button" class="game-button mt-4 hidden">Save Current Game</button> </div> </div>
    <div id="host-game-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeModal('host-game-modal')">&times;</span>
            <h2 class="text-xl font-semibold mb-4">Host Game (P2P Placeholder)</h2>
            <p>Share this three-word key with your opponent:</p>
            <p id="invite-key" class="text-2xl font-bold my-4 text-center bg-gray-700 p-3 rounded">--- --- ---</p>
            <!-- Developer Note: The Jami P2P functionality below is a placeholder.
                 A real Jami client and integration logic are required for this to work.
                 The invite key is generated, but no actual network connection is established by this web page alone.
                 This modal simulates waiting for a connection but is non-functional for actual P2P. -->
            <p class="text-yellow-400 text-sm font-semibold">Waiting for opponent to join via Jami (THIS IS A STUB FEATURE)...</p>
            <p class="text-gray-400 text-sm mt-1">(Note: Actual Jami P2P connection and gameplay requires significant external setup and is NOT currently implemented in this application.)</p>
            <button class="game-button mt-4" onclick="closeModal('host-game-modal')">Close</button>
        </div>
    </div>
    <div id="join-game-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeModal('join-game-modal')">&times;</span>
            <h2 class="text-xl font-semibold mb-4">Join Game (P2P Placeholder)</h2>
            <label for="join-key-input">Enter the three-word key from the host:</label>
            <input type="text" id="join-key-input" class="text-input" placeholder="word-word-word">
            <!-- Developer Note: The Jami P2P functionality below is a placeholder.
                 Pressing 'Join' will simulate starting a P2P game locally but does not establish
                 a real network connection via Jami or any other P2P mechanism. -->
            <button id="confirm-join-button" class="game-button mt-4">Join via Jami (STUB FEATURE)</button>
            <p class="text-gray-400 text-sm mt-2">(Note: Actual Jami P2P connection and gameplay requires significant external setup and is NOT currently implemented in this application.)</p>
        </div>
    </div>
    <div id="tutorial-modal" class="modal"> <div class="modal-content"> <span class="modal-close" onclick="closeModal('tutorial-modal')">&times;</span> <h2 class="text-xl font-semibold mb-4">Go Tutorial</h2> <div id="tutorial-content" class="space-y-4 max-h-96 overflow-y-auto"> <div class="tutorial-card"> <h3 class="font-semibold text-lg mb-2">1. The Board & Stones</h3> <p>Go is played on a grid (commonly 9x9, 13x13, or 19x19). Players take turns placing black and white stones on the intersections of the lines, not inside the squares.</p> </div> <div class="tutorial-card"> <h3 class="font-semibold text-lg mb-2">2. Objective</h3> <p>The goal is to surround more territory (empty intersections) than your opponent. You also score points for captured stones.</p> </div> <div class="tutorial-card"> <h3 class="font-semibold text-lg mb-2">3. Placing Stones</h3> <p>Click on an empty intersection to place your stone. Black plays first.</p> </div> <div class="tutorial-card"> <h3 class="font-semibold text-lg mb-2">4. Liberties & Capture</h3> <p>A stone or group of connected stones needs "liberties" (adjacent empty intersections) to stay on the board. If a player places a stone that removes the last liberty of an opponent's stone or group, those stones are captured and removed from the board.</p> <p class="mt-1 text-sm text-gray-300">Example: If a white stone is surrounded on all four adjacent intersections by black stones, the white stone is captured.</p> </div> <div class="tutorial-card"> <h3 class="font-semibold text-lg mb-2">5. Illegal Moves</h3> <ul> <li><strong>Suicide:</strong> You cannot place a stone that results in its own immediate capture unless that move simultaneously captures opponent stones.</li> <li><strong>Ko Rule:</strong> You cannot immediately recapture a single stone if doing so would return the board to the exact state it was in just before your opponent's previous move. You must play elsewhere first.</li> </ul> </div> <div class="tutorial-card"> <h3 class="font-semibold text-lg mb-2">6. Passing & Ending the Game</h3> <p>If you believe there are no more useful moves, you can "Pass". The game ends when both players pass consecutively. Then, territory and captures are counted to determine the winner.</p> </div> <div class="tutorial-card"> <h3 class="font-semibold text-lg mb-2">7. Scoring</h3> <p>The game is scored by counting territory and captures. <strong>Territory</strong> consists of the empty intersections you have completely surrounded with your stones. Each captured opponent stone also counts as one point. <strong>Komi</strong> (typically 5.5 to 7.5 points) is added to White's score to compensate for Black playing first. This value can often be adjusted in the Settings. The player with the higher total score (territory + captures + Komi for White) wins.</p> </div> </div> <button class="game-button mt-6" onclick="closeModal('tutorial-modal')">Got it!</button> </div> </div>
    <div id="about-modal" class="modal"> <div class="modal-content"> <span class="modal-close" onclick="closeModal('about-modal')">&times;</span> <h2 class="text-xl font-semibold mb-4">About Go Master</h2> <p>Go Master - Part of the RobinsAI.world Board Game Series.</p> <p class="mt-2">This interactive Go game features Player vs. Player (P2P functionality is a STUB and requires external Jami setup) and Player vs. AI modes, implementing standard Go rules including area scoring and configurable Komi.</p> <p class="mt-4 text-sm text-gray-400">Developed with HTML, Tailwind CSS, and JavaScript.</p> <button class="game-button mt-6" onclick="closeModal('about-modal')">Close</button> </div> </div>
    <div id="settings-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeModal('settings-modal')">&times;</span>
            <h2 class="text-xl font-semibold mb-4">Settings</h2>
            
            <div class="mb-4">
                <label for="komi-input" class="block text-sm font-medium text-gray-300 mb-1">Komi</label>
                <input type="number" id="komi-input" step="0.5" class="text-input w-full">
            </div>

            <div class="mb-6">
                <label for="ai-difficulty-select" class="block text-sm font-medium text-gray-300 mb-1">AI Difficulty</label>
                <select id="ai-difficulty-select" class="game-button bg-gray-700 text-white p-2 rounded w-full">
                    <option value="easy">Easy</option>,
                    <option value="medium">Medium (Placeholder)</option>
                </select>
            </div>

            <div class="flex justify-end space-x-3">
                <button class="game-button px-4 py-2" onclick="closeModal('settings-modal')">Close</button>
                <button id="save-settings-button" class="game-button bg-blue-600 hover:bg-blue-500 px-4 py-2">Save Settings</button>
            </div>
        </div>
    </div>

    <script>
        // Simple debug click handler
        document.addEventListener('click', function(e) {
            try {
                console.log('\n=== Click Debug ===');
                console.log('Target:', e.target.tagName, e.target.className);
                console.log(`Coords: (${e.clientX}, ${e.clientY})`);
                
                const intersection = e.target.closest('.intersection');
                if (intersection) {
                    const row = intersection.dataset.row;
                    const col = intersection.dataset.col;
                    console.log(`Intersection hit: (${row}, ${col})`);
                    const rect = intersection.getBoundingClientRect();
                    console.log(`Intersection bounds: (${rect.left}, ${rect.top}, ${rect.width}, ${rect.height})`);
                } else {
                    console.log('No intersection hit');
                }
                
                console.log('Event chain:', e.composedPath()
                    .filter(el => el instanceof Element)
                    .map(el => el.tagName + '.' + el.className)
                    .join(' -> ')
                );
            } catch (err) {
                console.error('Click debug error:', err.message);
            }
        }, true);

        // Initialize debug click handlers before anything else
        document.addEventListener('DOMContentLoaded', function initDebug() {
            console.log('Setting up debug handlers...');
            const board = document.getElementById('go-board');
            if (!board) {
                console.error('Could not find go-board element during debug init');
                return;
            }

            // Direct board click handler
            board.addEventListener('click', (e) => {
                console.log('\n=== Debug Board Click ===');
                console.log('Event:', {
                    type: e.type,
                    target: e.target.className,
                    x: e.clientX,
                    y: e.clientY,
                    boardRect: board.getBoundingClientRect()
                });
            }, true);  // Use capture phase

            // Mouse tracking
            const debugInfo = board.querySelector('.debug-info');
            board.addEventListener('mousemove', (e) => {
                if (debugInfo) {
                    const rect = board.getBoundingClientRect();
                    debugInfo.textContent = `Mouse: ${Math.round(e.clientX - rect.left)}, ${Math.round(e.clientY - rect.top)}`;
                }
            });

            console.log('Debug handlers initialized');
        });

        // --- Constants and State ---
        const BOARD_SIZE_SELECT = document.getElementById('board-size-select');
        const GO_BOARD = document.getElementById('go-board');
        const TURN_INDICATOR = document.getElementById('turn-indicator');
        const CAPTURE_INFO = document.getElementById('capture-info');
        const MESSAGE_AREA = document.getElementById('message-area');
        const SAVE_GAME_BTN = document.getElementById('save-game');
        const LOAD_GAME_BTN = document.getElementById('load-game');
        const HOST_GAME_BTN = document.getElementById('host-game');
        const JOIN_GAME_BTN = document.getElementById('join-game');
        const GET_HINT_BTN = document.getElementById('get-hint');
        const PASS_TURN_BTN = document.getElementById('pass-turn');
        const RESIGN_BTN = document.getElementById('resign-game');
        const NEW_GAME_PVP_BTN = document.getElementById('new-game-pvp');
        const NEW_GAME_PVC_BTN = document.getElementById('new-game-pvc');
        const IN_GAME_CONTROLS_CONTAINER = document.getElementById('in-game-controls-container');
        const INGAME_CONTROLS_HEADER = document.getElementById('ingame-controls-header');
        const INGAME_TITLE = document.getElementById('ingame-title');
        const INGAME_CONTROLS_TOGGLE_BTN = document.getElementById('ingame-controls-toggle-btn');
        const IN_GAME_CONTROLS = document.getElementById('in-game-controls'); // The actual buttons
        const TOGGLE_COORDS_BTN = document.getElementById('toggle-coordinates');
        const MENU_TOGGLE_BTN = document.getElementById('menu-toggle');
        const OPTIONS_MENU = document.getElementById('options-menu');
        const TUTORIAL_BTN = document.getElementById('tutorial-button');
        const ABOUT_BTN = document.getElementById('about-button');
        const SETTINGS_BTN = document.getElementById('settings-button');
        const KOMI_INPUT = document.getElementById('komi-input');
        const AI_DIFFICULTY_SELECT = document.getElementById('ai-difficulty-select');
        const SAVE_SETTINGS_BTN = document.getElementById('save-settings-button');


        const EMPTY = 0; const BLACK = 1; const WHITE = 2;
        const DEFAULT_GAME_MODE = 'pvc';
        const DEFAULT_BOARD_SIZE = 9;

        let boardSize = DEFAULT_BOARD_SIZE;
        let boardState = [];
        let currentPlayer = BLACK;
        let captures = { [BLACK]: 0, [WHITE]: 0 };
        let gameMode = null;
        let gameOver = true;
        let gameStarted = false;
        let passCounter = 0;
        let moveHistory = [];
        let showCoordinates = false;
        let currentHintVisual = null;
        let inGameControlsAreVisible = true; // For the accordion content within the tray
        let komi = 6.5; // Default Komi
        let aiDifficulty = 'easy'; // Default AI difficulty


        // --- Jami Placeholder Functions ---
        /**
         * [JAMI STUB] Placeholder for sending data to a Jami peer.
         * In a real Jami integration, this function would:
         * 1. Serialize the 'data' object (e.g., to JSON).
         * 2. Use the Jami daemon or library to send the serialized data to the peer identified by 'key'.
         * 3. Handle potential errors in sending.
         * This current version only logs to the console, simulating a send action.
         */
        const jamiSend = (key, data) => { console.log(`[JAMI STUB] Sending to key ${key}:`, data); };

        /**
         * [JAMI STUB] Placeholder for receiving data from a Jami peer.
         * In a real Jami integration, this function would typically be a callback triggered by the Jami client
         * when a message is received over the P2P network.
         * It would:
         * 1. Deserialize the incoming 'data' (e.g., from JSON if it was sent that way).
         * 2. Determine the type of message (e.g., move, pass, resign, chat).
         * 3. Call the appropriate game logic function to update the game state or UI.
         * This current version is primarily for illustrating where incoming P2P data would be processed.
         */
        const jamiReceive = (data) => {
            console.log("[JAMI STUB] Received data:", data);
            if (gameMode !== 'pvp') return;
            if (data.player === currentPlayer) { console.warn("Received move from current player, ignoring."); return; }
            if (data.type === 'move') { placeStone(data.row, data.col, data.player, true); }
            else if (data.type === 'pass') { handlePass(true); }
            else if (data.type === 'resign') { handleResign(true); }
            else if (data.type === 'gameStateSync') { loadGameState(data.state); }
        };

        // --- Game Logic ---
        function startGame(mode, size) {
            console.log('Starting new game:', { mode, size });
            gameMode = mode; boardSize = size;
            boardState = Array(size).fill(null).map(() => Array(size).fill(EMPTY));
            currentPlayer = BLACK; captures = { [BLACK]: 0, [WHITE]: 0 };
            gameOver = false;
            gameStarted = true;
            passCounter = 0; moveHistory = [JSON.stringify(boardState)];
            clearMessage(); updateTurnIndicator(); updateCaptureInfo();
            drawBoard();
            SAVE_GAME_BTN.disabled = false;
            HOST_GAME_BTN.disabled = (gameMode !== 'pvp');
            GET_HINT_BTN.disabled = (gameMode !== 'pvc');

            IN_GAME_CONTROLS_CONTAINER.classList.remove('hidden');
            setInGameControlsVisibility(true); 

            closeOptionsMenu(); 
            clearHint();
        }

        function drawEmptyBoard(size) {
             console.log('Drawing empty board:', { size });
             boardSize = size;
             boardState = Array(size).fill(null).map(() => Array(size).fill(EMPTY));
             currentPlayer = BLACK;
             captures = { [BLACK]: 0, [WHITE]: 0 };
             gameOver = true;
             gameStarted = false;
             passCounter = 0;
             moveHistory = [];
             clearMessage();
             TURN_INDICATOR.textContent = "Click board to start vs AI";
             updateCaptureInfo();
             drawBoard();
             SAVE_GAME_BTN.disabled = true; HOST_GAME_BTN.disabled = true; GET_HINT_BTN.disabled = true;
             IN_GAME_CONTROLS_CONTAINER.classList.add('hidden');
             clearHint();
        }

        function drawBoard() {
            console.log('=== Drawing Board ===');
            console.log('Board size:', boardSize);

            // Debug DOM state before changes
            console.log('Initial board state:', {
                board: GO_BOARD,
                innerHTML: GO_BOARD.innerHTML,
                rect: GO_BOARD.getBoundingClientRect()
            });

            // Create both layers
            GO_BOARD.innerHTML = `
                <div class="board-lines"></div>
                <div class="intersections-layer"></div>
            `;
            
            // Debug elements after creation
            const linesContainer = GO_BOARD.querySelector('.board-lines');
            const intersectionsLayer = GO_BOARD.querySelector('.intersections-layer');
            
            console.log('Layer elements:', {
                lines: linesContainer,
                intersections: intersectionsLayer
            });
            
            if (!linesContainer || !intersectionsLayer) {
                console.error("drawBoard: Required containers not found.");
                return;
            }

            // Set up click handlers immediately
            function setupClickHandlers() {
                console.log('Setting up click handlers...');
                
                // Board-level event delegation
                GO_BOARD.onclick = (e) => {
                    console.log('\n=== Board Click ===');
                    console.log('Click target:', e.target);
                    console.log('Event details:', {
                        clientX: e.clientX,
                        clientY: e.clientY,
                        target: e.target.className,
                        targetRect: e.target.getBoundingClientRect(),
                        intersection: e.target.closest('.intersection')?.dataset
                    });

                    // If we clicked an intersection, handle it
                    const intersection = e.target.closest('.intersection');
                    if (intersection) {
                        const row = parseInt(intersection.dataset.row);
                        const col = parseInt(intersection.dataset.col);
                        console.log('Intersection clicked:', { row, col });
                        handleIntersectionClick(row, col);
                    }
                };

                // Extra debug for hover events
                GO_BOARD.onmouseover = (e) => {
                    if (e.target.classList.contains('intersection')) {
                        console.log('Hovering intersection:', e.target.dataset);
                    }
                };
            }

            // Set up click handlers outside of requestAnimationFrame
            setupClickHandlers();

            requestAnimationFrame(() => {
                
                linesContainer.innerHTML = '';
                intersectionsLayer.innerHTML = '';

                // Debug board dimensions
                // const boardWidth = GO_BOARD.clientWidth; // Old: use GO_BOARD width
                const drawingAreaWidth = linesContainer.clientWidth; // New: use width of the actual drawing container
                const boardHeight = linesContainer.clientHeight; // Use height of drawing container for consistency

                console.log('Board dimensions (drawing area):', {
                    width: drawingAreaWidth,
                    height: boardHeight,
                    clientRect: linesContainer.getBoundingClientRect(),
                    goBoardClientRect: GO_BOARD.getBoundingClientRect()
                });

                if (drawingAreaWidth === 0) {
                    console.warn("drawBoard: drawingAreaWidth is 0, retrying...");
                    setTimeout(drawBoard, 50);
                    return;
                }

                // Calculate cell size based on drawing area dimensions
                const boardPadding = 0; // New: CSS inset handles the main padding. This is for any additional internal padding.
                const effectiveBoardWidth = drawingAreaWidth - (2 * boardPadding); // boardPadding is currently 0
                const cellSize = (boardSize > 1) ? effectiveBoardWidth / (boardSize - 1) : effectiveBoardWidth;
                console.log('drawBoard: Calculated cellSize:', cellSize); // Added log

                console.log('Board measurements:', {
                    drawingAreaWidth,
                    boardPadding, // This is the JS internal padding, now 0
                    effectiveBoardWidth,
                    cellSize
                });

                // Draw grid lines
                for (let i = 0; i < boardSize; i++) {
                    const lineOffset = i * cellSize;
                    const hLine = document.createElement('div');
                    hLine.className = 'line h-line';
                    hLine.style.cssText = `top:${lineOffset}px; left:0; width:100%;`;
                    linesContainer.appendChild(hLine);

                    const vLine = document.createElement('div');
                    vLine.className = 'line v-line';
                    vLine.style.cssText = `left:${lineOffset}px; top:0; height:100%;`;
                    linesContainer.appendChild(vLine);
                }

                // Draw star points
                const starPoints = getStarPoints(boardSize);
                starPoints.forEach(p => {
                    const star = document.createElement('div');
                    star.className = 'star-point';
                    const starOffsetRow = p.row * cellSize;
                    const starOffsetCol = p.col * cellSize;
                    star.style.cssText = `top:${starOffsetRow}px; left:${starOffsetCol}px;`;
                    linesContainer.appendChild(star);
                });

                // Clear existing intersections and stones
                GO_BOARD.querySelectorAll('.intersection').forEach(inter => inter.remove());
                GO_BOARD.querySelectorAll('.stone').forEach(s => s.remove());

                // Create new intersections at each grid point
                // Debug total intersections being created
                console.log(`Creating ${boardSize * boardSize} intersections in intersections layer...`);
                
                // Create debug info
                const debugInfo = document.createElement('div');
                debugInfo.className = 'debug-info';
                GO_BOARD.appendChild(debugInfo);

                // Create intersections grid
                console.log('\n=== Creating Intersections ===');
                let loggedStone = false; // For logging stone details only once per drawBoard call
                for (let r = 0; r < boardSize; r++) {
                    for (let c = 0; c < boardSize; c++) {
                        const intersection = document.createElement('div');
                        intersection.className = 'intersection';
                        intersection.dataset.row = r;
                        intersection.dataset.col = c;

                        // Calculate position relative to intersectionsLayer (which is already inset by 20px CSS)
                        // boardPadding is the JS internal padding, currently 0
                        const top = boardPadding + (r * cellSize);
                        const left = boardPadding + (c * cellSize);

                        // Log for specific intersections' calculated styles
                        if ((r === 0 && c === 0) || (boardSize === 9 && r === 4 && c === 4) || (boardSize === 19 && r === 9 && c === 9) || (boardSize === 13 && r === 6 && c === 6) ) {
                            console.log(`drawBoard: Intersection (${r},${c}) calculated style top/left:`, `${top}px`, `${left}px`);
                        }
                        
                        // Add debug label
                        intersection.textContent = `${r},${c}`;

                        // Set position and style
                        Object.assign(intersection.style, {
                            position: 'absolute',
                            top: `${top}px`,
                            left: `${left}px`,
                            width: '30px', // Fixed size for interaction, might need to be cellSize dependent
                            height: '30px',
                            transform: 'translate(-50%, -50%)', // Center the intersection div
                            zIndex: '20',
                            cursor: 'pointer',
                            backgroundColor: 'rgba(255, 0, 0, 0.3)', // Debug color
                            border: '2px solid rgba(255, 0, 0, 0.5)', // Debug border
                            borderRadius: '50%',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            fontSize: '8px', // For the r,c text
                            color: 'black',
                            pointerEvents: 'auto'
                        });
                        
                        // Direct click handler for debugging and actual play
                        intersection.onclick = (e) => {
                            e.stopPropagation(); // Prevent board-level click if intersection is hit
                            console.log(`Intersection Clicked: Row ${r}, Col ${c}. Style Top: ${intersection.style.top}, Left: ${intersection.style.left}`);
                            handleIntersectionClick(r, c);
                        };
                        
                        // Add mouse tracking and hover debug
                        intersection.onmouseover = (e) => {
                            const rect = intersection.getBoundingClientRect();
                            debugInfo.textContent = `Mouse over (${r},${c}) at ${Math.round(e.clientX - rect.left)}, ${Math.round(e.clientY - rect.top)}`;
                            intersection.style.backgroundColor = 'rgba(255, 255, 0, 0.5)'; // Hover highlight
                        };
                        
                        intersection.onmouseout = () => {
                            debugInfo.textContent = '';
                            intersection.style.backgroundColor = 'rgba(255, 0, 0, 0.3)'; // Reset to debug color
                        };
                        
                        intersectionsLayer.appendChild(intersection);
                        if (showCoordinates) { addCoordLabels(intersection, r, c); } // This was outside the loop, should be inside

                        // Stone Rendering: Stones are children of GO_BOARD
                        if (boardState[r][c] !== EMPTY) {
                            const stone = document.createElement('div');
                            stone.className = `stone ${boardState[r][c] === BLACK ? 'black-stone' : 'white-stone'}`;
                            const stoneSize = cellSize * 0.85; // Stone size based on cellSize

                            // Calculate stone position relative to GO_BOARD
                            // Need to account for the 20px CSS inset of the intersectionsLayer
                            const cssInset = 20; // The fixed inset value from CSS for layers
                                                     // boardPadding is the JS internal padding, currently 0
                            const stoneTop = cssInset + boardPadding + (r * cellSize) - (stoneSize / 2);
                            const stoneLeft = cssInset + boardPadding + (c * cellSize) - (stoneSize / 2);

                            if (stoneSize > 0 && !isNaN(stoneTop) && !isNaN(stoneLeft)) {
                                stone.style.cssText = `
                                    position: absolute;
                                    top: ${stoneTop}px;
                                    left: ${stoneLeft}px;
                                    width: ${stoneSize}px;
                                    height: ${stoneSize}px;
                                    border-radius: 50%; /* Ensure stone is round */
                                    z-index: 2; /* Ensure stones are above lines but below intersection hover effects if any */
                                `;
                                // GO_BOARD.appendChild(stone); // Original append
                                // For logging, we need style applied, so set it first.
                                stone.style.cssText = styleText; // Apply style
                                GO_BOARD.appendChild(stone); // Then append

                                if (!loggedStone) {
                                    console.log(`drawBoard: Stone at (${r},${c}) style top/left/width/height:`, stone.style.top, stone.style.left, stone.style.width, stone.style.height);
                                    loggedStone = true;
                                }
                            }
                        }
                    }
                }
                // Ensure existing hint visual is repositioned correctly if board redraws
                if (currentHintVisual && currentHintVisual.dataset.hintRow !== undefined) {
                     const r_hint = parseInt(currentHintVisual.dataset.hintRow);
                     const c_hint = parseInt(currentHintVisual.dataset.hintCol);
                     if (!isNaN(r_hint) && !isNaN(c_hint)) {
                        createAndPositionHintVisual(r_hint, c_hint, false);
                     }
                }
            });
        }

        function addCoordLabels(intersection, r, c) {
             const coordText = `${String.fromCharCode(65 + c)}${boardSize - r}`;
             const topLabel = document.createElement('span'); topLabel.className = 'coord-label'; topLabel.textContent = coordText;
             topLabel.style.cssText = `bottom: calc(50% + 5px); left: 50%; transform: translateX(-50%);`; intersection.appendChild(topLabel);
             if (r === boardSize - 1) { const bl = document.createElement('span'); bl.className = 'coord-label'; bl.textContent = String.fromCharCode(65 + c); bl.style.cssText = `top: calc(100% + 3px); left: 50%; transform: translateX(-50%);`; intersection.appendChild(bl); }
             if (c === 0) { const ll = document.createElement('span'); ll.className = 'coord-label'; ll.textContent = `${boardSize - r}`; ll.style.cssText = `right: calc(100% + 3px); top: 50%; transform: translateY(-50%);`; intersection.appendChild(ll); }
        }

        function getStarPoints(size) { if (size === 9) return [{row: 2, col: 2}, {row: 2, col: 6}, {row: 4, col: 4}, {row: 6, col: 2}, {row: 6, col: 6}]; if (size === 13) return [{row: 3, col: 3}, {row: 3, col: 9}, {row: 6, col: 6}, {row: 9, col: 3}, {row: 9, col: 9}]; if (size === 19) return [ {row: 3, col: 3}, {row: 3, col: 9}, {row: 3, col: 15}, {row: 9, col: 3}, {row: 9, col: 9}, {row: 9, col: 15}, {row: 15, col: 3}, {row: 15, col: 9}, {row: 15, col: 15} ]; return []; }

        function handleIntersectionClick(row, col) {
            console.log('handleIntersectionClick: Clicked on intersection (row, col):', row, col);
            // console.log('=== Handle Intersection Click ==='); // Keeping this for now, can be removed if too verbose
            // console.log(`Position: row ${row}, col ${col}`);
            console.log('Game state (at click):', { // Slightly changed original log
                gameStarted,
                gameOver,
                gameMode,
                currentPlayer,
                boardSize
            });

            if (gameOver) {
                console.log('Game is over, starting new game...');
                startGame(DEFAULT_GAME_MODE, DEFAULT_BOARD_SIZE);
                setMessage("Started default game (9x9 vs AI). Black's turn.");
                return;
            }
            clearHint();
            if (gameMode === 'pvc' && currentPlayer === WHITE) {
                setMessage("It's the AI's turn.");
                return;
            }
            const success = placeStone(row, col, currentPlayer);
            if (success && gameMode === 'pvc' && !gameOver) {
                 setTimeout(aiMove, 500);
            }
        }

        function placeStone(row, col, player, receivedMove = false) {
            clearMessage();
            clearHint();
            let messageForLog = ""; // For logging reason of invalid move

            if (boardState[row][col] !== EMPTY) {
                messageForLog = "Intersection occupied.";
                setMessage(messageForLog);
                console.log('placeStone: Move INVALID at (row, col):', row, col, 'Reason:', messageForLog);
                return false;
            }
            const tempBoardState = JSON.parse(JSON.stringify(boardState)); tempBoardState[row][col] = player; let capturedStonesInSim = 0; const opponent = player === BLACK ? WHITE : BLACK; let groupsToRemove = [];
            const neighbors = getNeighbors(row, col);
            // Renamed inner r,c to neighbor_r, neighbor_c to avoid confusion if debugging scopes
            for (const { r: neighbor_r, c: neighbor_c } of neighbors) {
                if (tempBoardState[neighbor_r][neighbor_c] === opponent) {
                    const group = findGroupSimulated(neighbor_r, neighbor_c, tempBoardState);
                    if (countLibertiesSimulated(group, tempBoardState) === 0) {
                        groupsToRemove.push(group);
                        capturedStonesInSim += group.stones.length;
                    }
                }
            }
            // Renamed inner r,c to stone_r, stone_c
            groupsToRemove.forEach(group => group.stones.forEach(({ r: stone_r, c: stone_c }) => tempBoardState[stone_r][stone_c] = EMPTY));
            const ownGroup = findGroupSimulated(row, col, tempBoardState);
            if (countLibertiesSimulated(ownGroup, tempBoardState) === 0 && capturedStonesInSim === 0) {
                messageForLog = "Illegal move: Suicide.";
                setMessage(messageForLog);
                console.log('placeStone: Move INVALID at (row, col):', row, col, 'Reason:', messageForLog);
                return false;
            }
            const potentialStateString = JSON.stringify(tempBoardState);
            if (moveHistory.length > 1 && potentialStateString === moveHistory[moveHistory.length - 2]) {
                messageForLog = "Illegal move: Ko violation.";
                setMessage(messageForLog);
                console.log('placeStone: Move INVALID at (row, col):', row, col, 'Reason:', messageForLog);
                return false;
            }
            boardState[row][col] = player; let actualCapturedStones = 0;
            // Renamed inner r,c to stone_r, stone_c
            groupsToRemove.forEach(group => group.stones.forEach(({ r: stone_r, c: stone_c }) => {
                if (boardState[stone_r][stone_c] !== EMPTY) {
                    boardState[stone_r][stone_c] = EMPTY;
                    actualCapturedStones++;
                }
            }));
            captures[player] += actualCapturedStones; passCounter = 0; moveHistory.push(JSON.stringify(boardState));

            console.log('placeStone: Successfully placed stone for player', player, 'at (row, col):', row, col); // Added log

            drawBoard(); updateCaptureInfo(); currentPlayer = opponent; updateTurnIndicator();
            if (gameMode === 'pvp' && !receivedMove) { jamiSend(document.getElementById('invite-key')?.textContent || 'default-key', { type: 'move', player, row, col, boardState }); } return true;
        }

        function getNeighbors(r, c) { const neighbors = []; const deltas = [[-1, 0], [1, 0], [0, -1], [0, 1]]; for (const [dr, dc] of deltas) { const nr = r + dr; const nc = c + dc; if (nr >= 0 && nr < boardSize && nc >= 0 && nc < boardSize) { neighbors.push({ r: nr, c: nc }); } } return neighbors; }
        function findGroup(startR, startC) { return findGroupSimulated(startR, startC, boardState); }
        function countLiberties(group) { return countLibertiesSimulated(group, boardState); }

        function handlePass(receivedPass = false) { if (gameOver) return; clearMessage(); clearHint(); passCounter++; const opponent = currentPlayer === BLACK ? WHITE : BLACK; setMessage(`${currentPlayer === BLACK ? 'Black' : 'White'} passed.`); if (gameMode === 'pvp' && !receivedPass) { jamiSend(document.getElementById('invite-key')?.textContent || 'default-key', { type: 'pass', player: currentPlayer }); } currentPlayer = opponent; updateTurnIndicator(); if (passCounter >= 2) { endGame(); } else if (gameMode === 'pvc' && currentPlayer === WHITE && !gameOver) { setTimeout(aiMove, 500); } }
        function handleResign(receivedResign = false) { if (gameOver) return; clearHint(); const winner = currentPlayer === BLACK ? WHITE : BLACK; setMessage(`${currentPlayer === BLACK ? 'Black' : 'White'} resigned. ${winner === BLACK ? 'Black' : 'White'} wins!`); gameOver = true; TURN_INDICATOR.textContent = "Game Over"; SAVE_GAME_BTN.disabled = true; HOST_GAME_BTN.disabled = true; GET_HINT_BTN.disabled = true; if (gameMode === 'pvp' && !receivedResign) { jamiSend(document.getElementById('invite-key')?.textContent || 'default-key', { type: 'resign', player: currentPlayer }); } IN_GAME_CONTROLS_CONTAINER.classList.add('hidden');}
        function endGame() { gameOver = true; clearHint(); setMessage("Both players passed. Game Over. Scoring..."); const score = calculateScore(); TURN_INDICATOR.textContent = `Game Over! ${score.winner} wins. Score: B ${score.black} - W ${score.white}`; SAVE_GAME_BTN.disabled = true; HOST_GAME_BTN.disabled = true; GET_HINT_BTN.disabled = true; IN_GAME_CONTROLS_CONTAINER.classList.add('hidden'); }

        // --- Scoring Logic ---
        function calculateScore() {
            let blackTerritory = 0;
            let whiteTerritory = 0;
            const visited = Array(boardSize).fill(null).map(() => Array(boardSize).fill(false));
            // Komi is now a global variable, loaded from settings

            for (let r = 0; r < boardSize; r++) {
                for (let c = 0; c < boardSize; c++) {
                    if (boardState[r][c] === EMPTY && !visited[r][c]) {
                        const { territory, owner } = floodFillAndIdentifyOwner(r, c, visited);
                        if (owner === BLACK) {
                            blackTerritory += territory;
                        } else if (owner === WHITE) {
                            whiteTerritory += territory;
                        }
                        // Neutral points are not added to any score
                    }
                }
            }

            const blackScore = blackTerritory + captures[BLACK];
            const whiteScore = whiteTerritory + captures[WHITE] + komi;

            setMessage("Scoring based on territory, captures + Komi.");
            return {
                black: blackScore,
                white: whiteScore,
                winner: whiteScore > blackScore ? 'White' : 'Black'
            };
        }

        function floodFillAndIdentifyOwner(startR, startC, visited) {
            const queue = [{ r: startR, c: startC }];
            visited[startR][startC] = true;
            let count = 0;
            let bordersBlack = false;
            let bordersWhite = false;
            const currentTerritoryPoints = [];

            while (queue.length > 0) {
                const { r, c } = queue.shift();
                count++;
                currentTerritoryPoints.push({r, c});

                const neighbors = getNeighbors(r, c);
                for (const neighbor of neighbors) {
                    if (boardState[neighbor.r][neighbor.c] === EMPTY && !visited[neighbor.r][neighbor.c]) {
                        visited[neighbor.r][neighbor.c] = true;
                        queue.push({ r: neighbor.r, c: neighbor.c });
                    } else if (boardState[neighbor.r][neighbor.c] === BLACK) {
                        bordersBlack = true;
                    } else if (boardState[neighbor.r][neighbor.c] === WHITE) {
                        bordersWhite = true;
                    }
                }
            }
            
            // Check all points in the identified region for borders
            // This is important because the initial flood fill only checks direct borders of the flood-filled points
            // A region might be bordered by both colors if it's large and snakes around
            const allPointsInRegion = [...currentTerritoryPoints]; // Use a copy if modifying currentTerritoryPoints
            const pointsToCheck = new Set(allPointsInRegion.map(p => `${p.r},${p.c}`));
            const boundaryQueue = [...allPointsInRegion];
            const checkedForBorder = new Set(); // To avoid re-checking same points for border determination

            while(boundaryQueue.length > 0){
                const {r,c} = boundaryQueue.shift();
                if(checkedForBorder.has(`${r},${c}`)) continue;
                checkedForBorder.add(`${r},${c}`);

                const neighbors = getNeighbors(r,c);
                for(const neighbor of neighbors){
                    // If neighbor is outside the current flood-filled region
                    if(!pointsToCheck.has(`${neighbor.r},${neighbor.c}`)){
                        if(boardState[neighbor.r][neighbor.c] === BLACK) bordersBlack = true;
                        else if(boardState[neighbor.r][neighbor.c] === WHITE) bordersWhite = true;
                    }
                }
            }


            if (bordersBlack && !bordersWhite) {
                return { territory: count, owner: BLACK };
            } else if (bordersWhite && !bordersBlack) {
                return { territory: count, owner: WHITE };
            } else {
                // Either borders both (neutral) or borders none (should not happen in a finished game if board is filled)
                return { territory: count, owner: EMPTY }; // EMPTY can signify neutral
            }
        }

        function evaluateTerritorialValue(row, col, player, currentBoardState) {
            let score = 0;
            const opponent = player === BLACK ? WHITE : BLACK;
            const tempBoardState = JSON.parse(JSON.stringify(currentBoardState));
            tempBoardState[row][col] = player; // Place the stone for evaluation

            // Helper to check ownership of an empty point's surroundings
            function checkEmptyPointInfluence(r, c) {
                let friendlyStones = 0;
                let opponentStones = 0;
                let emptyNeighbors = 0;
                const pointNeighbors = getNeighbors(r, c);
                for (const { r: nr, c: nc } of pointNeighbors) {
                    if (tempBoardState[nr][nc] === player) friendlyStones++;
                    else if (tempBoardState[nr][nc] === opponent) opponentStones++;
                    else emptyNeighbors++;
                }
                // Simple heuristic: strongly influenced if more friendly stones than opponent, and not too many empty
                if (friendlyStones > opponentStones && emptyNeighbors <= 2) return 1; // Potential territory
                if (friendlyStones > 0 && opponentStones === 0 && emptyNeighbors <=3) return 0.5; // Weaker influence
                return 0;
            }

            // 1. Check direct influence on adjacent empty spots
            const directNeighbors = getNeighbors(row, col);
            for (const { r: nr, c: nc } of directNeighbors) {
                if (tempBoardState[nr][nc] === EMPTY) {
                    score += checkEmptyPointInfluence(nr, nc);
                }
                // 2. Bonus for connecting to own stones or forming a wall
                else if (tempBoardState[nr][nc] === player) {
                    score += 0.2; // Small bonus for connecting
                }
                // 3. Bonus for pushing against opponent stones (potential to cut or reduce)
                else if (tempBoardState[nr][nc] === opponent) {
                    score += 0.1;
                }
            }
            
            // 4. Consider liberties of the new stone/group - more liberties is generally good
            const ownGroup = findGroupSimulated(row, col, tempBoardState);
            const liberties = countLibertiesSimulated(ownGroup, tempBoardState);
            if (liberties === 1) score -= 2; // Penalize moves that result in 1 liberty unless capture
            if (liberties === 2) score += 0.1;
            if (liberties >= 3) score += 0.3;


            // 5. Check if the move solidifies territory around existing friendly stones
            // Iterate over friendly stones near the move and see if this move helps secure empty points near them
            for (const { r: nr, c: nc } of directNeighbors) { // Check around the placed stone
                if (tempBoardState[nr][nc] === player) { // If there's an existing friendly stone
                    const friendlyStoneNeighbors = getNeighbors(nr, nc);
                    for (const {r: nnr, c: nnc} of friendlyStoneNeighbors) {
                        if (tempBoardState[nnr][nnc] === EMPTY) { // For empty points next to that friendly stone
                           score += checkEmptyPointInfluence(nnr, nnc) * 0.5; // Add weighted score
                        }
                    }
                }
            }
            return score;
        }


        function aiMove() {
            if (gameOver || currentPlayer !== WHITE || gameMode !== 'pvc') return;
            setMessage("AI is thinking...");
            TURN_INDICATOR.textContent = "AI's Turn (White)";

            // Placeholder for AI difficulty based logic
            // if (aiDifficulty === 'easy') { ... } else if (aiDifficulty === 'medium') { ... }

            let validMoves = [];
            for (let r = 0; r < boardSize; r++) {
                for (let c = 0; c < boardSize; c++) {
                    if (isValidMove(r, c, WHITE)) {
                        validMoves.push({ r, c });
                    }
                }
            }

            if (validMoves.length === 0) {
                handlePass();
                setMessage("AI passes.");
                return;
            }

            let bestMove = null;
            let maxCaptures = -1;
            let bestCaptureMove = null;

            // 1. Prioritize Captures
            for (const move of validMoves) {
                const tempBoardStateCapture = JSON.parse(JSON.stringify(boardState));
                tempBoardStateCapture[move.r][move.c] = WHITE;
                let capturesMade = 0;
                const opponent = BLACK;
                const neighbors = getNeighbors(move.r, move.c);
                
                for (const { r: nr, c: nc } of neighbors) {
                    if (tempBoardStateCapture[nr][nc] === opponent) {
                        const group = findGroupSimulated(nr, nc, tempBoardStateCapture);
                        if (countLibertiesSimulated(group, tempBoardStateCapture) === 0) {
                            // Need to simulate removal for correct liberty count of AI's subsequent group
                            const groupStones = group.stones;
                            groupStones.forEach(s => tempBoardStateCapture[s.r][s.c] = EMPTY);
                            capturesMade += groupStones.length;
                        }
                    }
                }
                
                // Check for suicide only if no captures were made by this move
                if (capturesMade > 0) {
                     const ownGroupAfterCapture = findGroupSimulated(move.r, move.c, tempBoardStateCapture);
                     if (countLibertiesSimulated(ownGroupAfterCapture, tempBoardStateCapture) > 0) { // Not suicide after capture
                        if (capturesMade > maxCaptures) {
                            maxCaptures = capturesMade;
                            bestCaptureMove = move;
                        }
                     }
                }
            }

            if (bestCaptureMove) {
                bestMove = bestCaptureMove;
            } else {
                // 2. Territorial Evaluation
                let bestTerritorialScore = -Infinity;
                let goodTerritorialMoves = [];

                for (const move of validMoves) {
                    // Ensure the move is not suicide (even if it doesn't capture)
                    const tempBoardStateNoCapture = JSON.parse(JSON.stringify(boardState));
                    tempBoardStateNoCapture[move.r][move.c] = WHITE;
                    const ownGroup = findGroupSimulated(move.r, move.c, tempBoardStateNoCapture);
                    if (countLibertiesSimulated(ownGroup, tempBoardStateNoCapture) === 0) {
                        continue; // Skip suicidal moves if they don't capture
                    }

                    const territorialScore = evaluateTerritorialValue(move.r, move.c, WHITE, boardState);
                    if (territorialScore > bestTerritorialScore) {
                        bestTerritorialScore = territorialScore;
                        goodTerritorialMoves = [move];
                    } else if (territorialScore === bestTerritorialScore) {
                        goodTerritorialMoves.push(move);
                    }
                }

                if (goodTerritorialMoves.length > 0) {
                    bestMove = goodTerritorialMoves[Math.floor(Math.random() * goodTerritorialMoves.length)];
                } else {
                    // 3. Fallback: Random valid move (already filtered for basic suicide)
                    // validMoves should already contain non-suicidal moves if they don't capture.
                    // The isValidMove function checks for basic suicide.
                    // If a move leads to immediate self-capture without capturing opponent stones, isValidMove returns false.
                    // So, we can pick randomly from the remaining validMoves.
                    if (validMoves.length > 0) {
                         bestMove = validMoves[Math.floor(Math.random() * validMoves.length)];
                    } else {
                        // This case should ideally be covered by the initial validMoves.length === 0 check
                        // but as a safeguard:
                        handlePass();
                        setMessage("AI passes (no valid non-suicidal moves).");
                        return;
                    }
                }
            }
            
            // If after all considerations, no bestMove is found (e.g. all moves are suicidal without capture
            // and no good territorial moves), AI should pass. This is unlikely if validMoves has items.
            if (!bestMove && validMoves.length > 0) {
                 // This can happen if all valid moves were filtered out by territorial logic as having negative scores,
                 // and we didn't explicitly keep a "least bad" option.
                 // For now, pick a random one from original valid moves if goodTerritorialMoves is empty.
                 bestMove = validMoves[Math.floor(Math.random() * validMoves.length)];
            } else if (!bestMove) { // No valid moves at all
                handlePass();
                setMessage("AI passes (no moves found).");
                return;
            }


            const success = placeStone(bestMove.r, bestMove.c, WHITE);
            if (!success) {
                console.error("AI failed to make a calculated move, attempting random fallback or pass.", bestMove);
                // Try a truly random valid move if the calculated one failed (should be rare)
                const randomFallbackMove = validMoves[Math.floor(Math.random() * validMoves.length)];
                if (randomFallbackMove && placeStone(randomFallbackMove.r, randomFallbackMove.c, WHITE)) {
                     setMessage(`AI made a random fallback move to ${String.fromCharCode(65 + randomFallbackMove.c)}${boardSize - randomFallbackMove.r}`);
                } else {
                    handlePass();
                    setMessage("AI error, passes.");
                }
            } else {
                setMessage(`AI placed at ${String.fromCharCode(65 + bestMove.c)}${boardSize - bestMove.r}`);
            }
        }
        function isValidMove(row, col, player) { if (row < 0 || row >= boardSize || col < 0 || col >= boardSize || boardState[row][col] !== EMPTY) { return false; } const tempBoardState = JSON.parse(JSON.stringify(boardState)); tempBoardState[row][col] = player; let capturedStonesCount = 0; const opponent = player === BLACK ? WHITE : BLACK; const neighbors = getNeighbors(row, col); for (const { r, c } of neighbors) { if (tempBoardState[r][c] === opponent) { const group = findGroupSimulated(r, c, tempBoardState); if (countLibertiesSimulated(group, tempBoardState) === 0) { capturedStonesCount += group.stones.length; group.stones.forEach(s => tempBoardState[s.r][s.c] = EMPTY); } } } const ownGroup = findGroupSimulated(row, col, tempBoardState); if (countLibertiesSimulated(ownGroup, tempBoardState) === 0 && capturedStonesCount === 0) { return false; } const potentialStateString = JSON.stringify(tempBoardState); if (moveHistory.length > 1 && potentialStateString === moveHistory[moveHistory.length - 2]) { return false; } return true; }
        function findGroupSimulated(startR, startC, simBoardState) { const color = simBoardState[startR][startC]; if (color === EMPTY) return { stones: [] }; const group = new Set(); const queue = [{ r: startR, c: startC }]; const visited = new Set([`${startR},${startC}`]); const size = simBoardState.length; while (queue.length > 0) { const { r, c } = queue.shift(); group.add(`${r},${c}`); const simNeighbors = getNeighbors(r, c); for (const { r: nr, c: nc } of simNeighbors) { const posString = `${nr},${nc}`; if (nr >= 0 && nr < size && nc >= 0 && nc < size) { const neighborState = simBoardState[nr][nc]; if (neighborState === color && !visited.has(posString)) { visited.add(posString); queue.push({ r: nr, c: nc }); } } } } const stoneCoords = Array.from(group).map(s => { const [r, c] = s.split(',').map(Number); return { r, c }; }); return { stones: stoneCoords }; }
        function countLibertiesSimulated(group, simBoardState) { const liberties = new Set(); const size = simBoardState.length; if (!group || !group.stones) return 0; for (const stone of group.stones) { const simNeighbors = getNeighbors(stone.r, stone.c); for (const { r: nr, c: nc } of simNeighbors) { if (nr >= 0 && nr < size && nc >= 0 && nc < size) { if (simBoardState[nr][nc] === EMPTY) { liberties.add(`${nr},${nc}`); } } } } return liberties.size; }

        // --- UI Updates ---
        function updateTurnIndicator() { TURN_INDICATOR.textContent = gameOver ? "Click board to start vs AI" : `${currentPlayer === BLACK ? 'Black' : 'White'}'s Turn`; }
        function updateCaptureInfo() { CAPTURE_INFO.textContent = `Black Captures: ${captures[BLACK]} | White Captures: ${captures[WHITE]}`; }
        function setMessage(msg) { MESSAGE_AREA.textContent = msg; }
        function clearMessage() { MESSAGE_AREA.textContent = ''; }
        function toggleCoordinates() { showCoordinates = !showCoordinates; drawBoard(); }

        // --- Menu Toggle (Main Options Menu) ---
        function toggleOptionsMenu() { OPTIONS_MENU.classList.toggle('open'); }
        function closeOptionsMenu() { OPTIONS_MENU.classList.remove('open'); }

        // --- In-Game Controls Accordion Toggle (Content within the Tray) ---
        function toggleInGameControlsAccordion() { // Renamed for clarity
            setInGameControlsVisibility(!inGameControlsAreVisible);
        }

        function setInGameControlsVisibility(visible) { // For accordion content
            inGameControlsAreVisible = visible;
            if (visible) {
                IN_GAME_CONTROLS.classList.remove('hidden');
                INGAME_CONTROLS_TOGGLE_BTN.classList.remove('collapsed');
            } else {
                IN_GAME_CONTROLS.classList.add('hidden');
                INGAME_CONTROLS_TOGGLE_BTN.classList.add('collapsed');
            }
        }

        // --- Modals ---
        function openModal(modalId) { const modal = document.getElementById(modalId); if(modal) modal.style.display = 'flex'; }
        function closeModal(modalId) { const modal = document.getElementById(modalId); if(modal) modal.style.display = 'none'; }
        function setupModalInteractions() {
            window.addEventListener('click', (event) => { document.querySelectorAll('.modal').forEach(modal => { if (event.target == modal) closeModal(modal.id); }); });
            TUTORIAL_BTN.onclick = () => { openModal('tutorial-modal'); closeOptionsMenu(); };
            ABOUT_BTN.onclick = () => { openModal('about-modal'); closeOptionsMenu(); };
            SETTINGS_BTN.onclick = () => {
                // Populate modal with current settings before opening
                KOMI_INPUT.value = komi;
                AI_DIFFICULTY_SELECT.value = aiDifficulty;
                openModal('settings-modal');
                closeOptionsMenu();
            };
            LOAD_GAME_BTN.onclick = () => { showSaveLoadModal(false); closeOptionsMenu(); };
            JOIN_GAME_BTN.onclick = () => { openModal('join-game-modal'); closeOptionsMenu(); };
            SAVE_GAME_BTN.onclick = () => { showSaveLoadModal(true); closeOptionsMenu(); };
            HOST_GAME_BTN.onclick = () => { showHostGameModal(); closeOptionsMenu(); };
            SAVE_SETTINGS_BTN.onclick = saveSettings;
            document.getElementById('confirm-join-button').onclick = attemptJoinGame;
        }

        // --- Settings Management ---
        function loadSettings() {
            const savedKomi = localStorage.getItem('goGameKomi');
            const savedAiDifficulty = localStorage.getItem('goGameAiDifficulty');

            if (savedKomi !== null) {
                komi = parseFloat(savedKomi);
            }
            if (savedAiDifficulty !== null) {
                aiDifficulty = savedAiDifficulty;
            }
            // Update input fields in the modal as well, though they are also updated on open
            KOMI_INPUT.value = komi;
            AI_DIFFICULTY_SELECT.value = aiDifficulty;
        }

        function saveSettings() {
            const newKomi = parseFloat(KOMI_INPUT.value);
            const newAiDifficulty = AI_DIFFICULTY_SELECT.value;

            if (isNaN(newKomi)) {
                setMessage("Invalid Komi value. Please enter a number.");
                return;
            }

            komi = newKomi;
            aiDifficulty = newAiDifficulty;

            try {
                localStorage.setItem('goGameKomi', komi.toString());
                localStorage.setItem('goGameAiDifficulty', aiDifficulty);
                setMessage("Settings saved.");
            } catch (e) {
                console.error("Error saving settings to localStorage:", e);
                setMessage("Could not save settings. Storage might be full or restricted.");
            }
            
            closeModal('settings-modal');
        }


        // --- Save / Load ---
        const SAVE_SLOT_PREFIX = 'goGameSave_';
        function getGameState() { return { boardSize, boardState, currentPlayer, captures, gameMode, gameOver, passCounter, moveHistory, showCoordinates, inGameControlsAreVisible }; }
        function loadGameState(state) { if (!state) return; ({ boardSize, boardState, currentPlayer, captures, gameMode, gameOver, passCounter, moveHistory = [JSON.stringify(state.boardState)], showCoordinates = false, inGameControlsAreVisible = true } = state); clearMessage(); updateTurnIndicator(); updateCaptureInfo(); drawBoard(); SAVE_GAME_BTN.disabled = gameOver; HOST_GAME_BTN.disabled = gameOver || (gameMode !== 'pvp'); GET_HINT_BTN.disabled = gameOver || (gameMode !== 'pvc'); if (gameOver) { IN_GAME_CONTROLS_CONTAINER.classList.add('hidden');} else { IN_GAME_CONTROLS_CONTAINER.classList.remove('hidden'); setInGameControlsVisibility(inGameControlsAreVisible); } setMessage(`Game loaded. ${gameOver ? 'Game is over.' : ''}`); }
        function showSaveLoadModal(isSaving) { const modal = document.getElementById('save-load-modal'); const title = document.getElementById('save-load-title'); const listDiv = document.getElementById('saved-games-list'); const nameInput = document.getElementById('save-name-input'); const saveButton = document.getElementById('confirm-save-button'); listDiv.innerHTML = ''; title.textContent = isSaving ? "Save Game" : "Load Game"; nameInput.style.display = isSaving ? 'block' : 'none'; saveButton.style.display = isSaving ? 'block' : 'none'; nameInput.value = ''; let hasSaves = false; try { for (let i = 0; i < localStorage.length; i++) { const key = localStorage.key(i); if (key?.startsWith(SAVE_SLOT_PREFIX)) { hasSaves = true; const saveName = key.substring(SAVE_SLOT_PREFIX.length); const gameEntry = document.createElement('div'); gameEntry.className = 'flex justify-between items-center p-2 bg-gray-700 rounded mb-2'; const nameSpan = document.createElement('span'); nameSpan.textContent = saveName; nameSpan.className = 'mr-2 truncate'; gameEntry.appendChild(nameSpan); const actionsDiv = document.createElement('div'); actionsDiv.className = 'flex-shrink-0'; if (!isSaving) { const loadBtn = document.createElement('button'); loadBtn.textContent = 'Load'; loadBtn.className = 'game-button text-sm px-2 py-1 mr-1'; loadBtn.onclick = (e) => { e.stopPropagation(); try { const savedState = JSON.parse(localStorage.getItem(key)); loadGameState(savedState); closeModal('save-load-modal'); } catch (err) { console.error("Load error:", err); setMessage("Error loading game."); } }; actionsDiv.appendChild(loadBtn); } const deleteBtn = document.createElement('button'); deleteBtn.textContent = 'Delete'; deleteBtn.className = 'game-button text-sm px-2 py-1 bg-red-700 hover:bg-red-600'; deleteBtn.onclick = (e) => { e.stopPropagation(); if (window.confirm(`Delete "${saveName}"? This action cannot be undone.`)) { localStorage.removeItem(key); showSaveLoadModal(isSaving); } }; actionsDiv.appendChild(deleteBtn); gameEntry.appendChild(actionsDiv); listDiv.appendChild(gameEntry); } } } catch (e) { console.error("localStorage access error:", e); listDiv.innerHTML = '<p class="text-red-400">Could not access saves. Check browser settings.</p>'; } if (!hasSaves && !listDiv.querySelector('p')) { listDiv.innerHTML = '<p class="text-gray-400">No saved games found.</p>'; } saveButton.onclick = (e) => { e.stopPropagation(); let saveName = nameInput.value.trim(); if (!saveName) { const d=new Date(); saveName = `Game_${d.toISOString().slice(0,10)}_${d.toTimeString().slice(0,5).replace(':','')}`; } const key = SAVE_SLOT_PREFIX + saveName; try { if (localStorage.getItem(key) && !window.confirm(`A save named "${saveName}" already exists. Overwrite?`)) { return; } localStorage.setItem(key, JSON.stringify(getGameState())); setMessage(`Game saved as "${saveName}".`); closeModal('save-load-modal'); } catch (err) { console.error("Save error:", err); setMessage("Error saving game. Storage might be full."); } }; openModal('save-load-modal'); }

        // --- PvP Invite/Join ---
        const wordList = ["fox", "jump", "quick", "brown", "lazy", "dog", "over", "log", "river", "flow", "stone", "path", "wind", "sun", "moon", "star", "cloud", "rain", "snow", "tree", "leaf", "root", "bird", "song", "fly", "high", "deep", "blue", "red", "gold", "wise", "calm", "fast", "slow", "dark", "light", "new", "old", "true", "kind"];
        function generateInviteKey() { const words = []; const len = wordList.length; if (window.crypto?.getRandomValues) { const idx = new Uint32Array(3); window.crypto.getRandomValues(idx); for (let i = 0; i < 3; i++) words.push(wordList[idx[i] % len]); } else { console.warn("Using fallback Math.random for key generation."); for (let i = 0; i < 3; i++) words.push(wordList[Math.floor(Math.random() * len)]); } return words.join('-'); }
        
        function showHostGameModal() {
            // [JAMI STUB] This function initiates a STUBBED P2P hosting process. No actual network communication occurs.
            if (gameMode !== 'pvp' || gameOver) { setMessage("Can only host active PvP games."); return; }
            const key = generateInviteKey();
            document.getElementById('invite-key').textContent = key;
            openModal('host-game-modal');
            // The console.log below simulates listening for a Jami connection, which is not actually happening.
            console.log(`[JAMI STUB] "Listening" on key (placeholder): ${key}. This is a simulation; no real network activity is initiated by this web page.`);
        }

        function attemptJoinGame() {
            // [JAMI STUB] This function initiates a STUBBED P2P joining process. No actual network communication occurs.
            const key = document.getElementById('join-key-input').value.trim().toLowerCase();
            if (!key || !/^[a-z]+(-[a-z]+){2}$/.test(key)) {
                setMessage("Invalid key format. Use three words separated by hyphens.");
                return;
            }
            closeModal('join-game-modal');
            setMessage(`Attempting to "join" game with key (placeholder): ${key}... This will start a local PvP game.`);
            // The console.log below simulates attempting a Jami connection, which is not actually happening.
            console.log(`[JAMI STUB] "Joining" key (placeholder): ${key}. This is a simulation; no real network activity is initiated by this web page.`);
            // This starts a local PvP game, not a true networked one.
            startGame('pvp', parseInt(BOARD_SIZE_SELECT.value));
        }

        // --- Hints ---
        function clearHint() {
            if (currentHintVisual && currentHintVisual.parentNode) {
                currentHintVisual.parentNode.removeChild(currentHintVisual);
            }
            currentHintVisual = null;
        }

        function explainHint(move) {
            const explanations = {
                "A2": "to secure territory on the lower left side and threaten Black's corner.",
                // Add more moves and explanations here as needed
                "default": "to strategically position your stone for potential territory gain."
            };
            return explanations[move] || explanations["default"];
        }

        function createAndPositionHintVisual(r, c, updateMessage = true) {
            clearHint();
            if (updateMessage) {
                const hintCoordinate = `${String.fromCharCode(65 + c)}${boardSize - r}`;
                const explanation = explainHint(hintCoordinate);
                setMessage(`Hint: Consider placing a stone at ${hintCoordinate} ${explanation}`);
            }

            // Consistent sizing logic with drawBoard
            const linesContainer = GO_BOARD.querySelector('.board-lines');
            if (!linesContainer) {
                console.error("Hint Error: linesContainer not found for measurements.");
                return;
            }
            const drawingAreaWidth = linesContainer.clientWidth;
            if (drawingAreaWidth === 0) { console.warn("Cannot create hint, drawingAreaWidth is 0."); return; }

            const jsInternalPadding = 0; // Consistent with drawBoard's current internal padding
            const effectiveBoardWidth_hint = drawingAreaWidth - (2 * jsInternalPadding);
            const cellSize_hint = (boardSize > 1) ? effectiveBoardWidth_hint / (boardSize - 1) : effectiveBoardWidth_hint;

            const hintVisual = document.createElement('div');
            hintVisual.className = 'hint-visual'; 
            hintVisual.dataset.hintRow = r; 
            hintVisual.dataset.hintCol = c;

            const hintSize = cellSize_hint * 0.9;
            const cssInset = 20; // The CSS inset used by linesContainer and intersectionsLayer

            // Hint is appended to GO_BOARD, so position needs to account for cssInset and any jsInternalPadding
            const hintTop = cssInset + jsInternalPadding + (r * cellSize_hint) - (hintSize / 2);
            const hintLeft = cssInset + jsInternalPadding + (c * cellSize_hint) - (hintSize / 2);

            if (hintSize > 0 && !isNaN(hintTop) && !isNaN(hintLeft)) {
                hintVisual.style.width = `${hintSize}px`;
                hintVisual.style.height = `${hintSize}px`;
                hintVisual.style.top = `${hintTop}px`;
                hintVisual.style.left = `${hintLeft}px`;
                GO_BOARD.appendChild(hintVisual); 
                currentHintVisual = hintVisual;
                if (updateMessage) {
                    const hintCoord = `${String.fromCharCode(65 + c)}${boardSize - r}`;
                    // Add explanation to hint if explainHint function exists
                    const baseHint = `Hint: Consider placing a stone at ${hintCoord}`;
                    const explanation = typeof explainHint === 'function' ? explainHint(hintCoord) : '';
                    setMessage(baseHint + explanation);
                }
            } else {
                console.warn("Could not calculate valid hint position/size.");
            }
        }

        function showHint() {
            if (gameOver || gameMode !== 'pvc' || currentPlayer !== BLACK) {
                setMessage("Hints are only available for your turn when playing against the AI.");
                return;
            }
            setMessage("Calculating hint...");
            let validMoves = [];
            for (let r_idx = 0; r_idx < boardSize; r_idx++) {
                for (let c_idx = 0; c_idx < boardSize; c_idx++) {
                    if (isValidMove(r_idx, c_idx, currentPlayer)) {
                        validMoves.push({ r: r_idx, c: c_idx });
                    }
                }
            }
            if (validMoves.length === 0) {
                setMessage("No valid moves found. You might need to pass.");
                return;
            }
            const hintMove = validMoves[Math.floor(Math.random() * validMoves.length)];
            createAndPositionHintVisual(hintMove.r, hintMove.c);
        }


        // --- Event Listeners ---
        function setupEventListeners() {
            if (MENU_TOGGLE_BTN) {
                 MENU_TOGGLE_BTN.onclick = toggleOptionsMenu;
            } else {
                console.error("Menu toggle button not found!");
            }
            if (INGAME_CONTROLS_HEADER) {
                INGAME_CONTROLS_HEADER.onclick = toggleInGameControlsAccordion;
            } else {
                console.error("In-game controls header not found!");
            }

            document.addEventListener('click', function(event) { if (OPTIONS_MENU && !OPTIONS_MENU.classList.contains('open')) { /* Do nothing if already closed */ } else if (OPTIONS_MENU && OPTIONS_MENU.classList.contains('open') && !OPTIONS_MENU.contains(event.target) && MENU_TOGGLE_BTN && !MENU_TOGGLE_BTN.contains(event.target)) { closeOptionsMenu(); } });

            // Add hover sound effect for empty intersections
            try {
                const hoverSound = document.getElementById('hoverSound');
                console.log('Hover sound element:', hoverSound);
                
                function playHoverSound() {
                    if (hoverSound) {
                        hoverSound.currentTime = 0; // Reset to start for rapid hovers
                        hoverSound.play().catch(error => {
                            console.warn("Audio playback failed:", error);
                        });
                    }
                }
                
                if (GO_BOARD) {
                    GO_BOARD.addEventListener('mouseover', function(event) {
                        if (event.target.classList.contains('intersection')) {
                            console.log('Hover over intersection detected');
                            const row = parseInt(event.target.dataset.row);
                            const col = parseInt(event.target.dataset.col);
                            if (boardState[row][col] === EMPTY) {
                                console.log(`Playing hover sound for empty intersection at ${row}, ${col}`);
                                playHoverSound();
                            }
                        }
                    });
                    console.log('Hover event listener added successfully');
                } else {
                    console.error('GO_BOARD element not found for hover listener');
                }
            } catch (error) {
                console.error('Error setting up hover sound:', error);
                console.error('Error stack:', error.stack);
            }
            NEW_GAME_PVP_BTN.onclick = () => { startGame('pvp', parseInt(BOARD_SIZE_SELECT.value)); closeOptionsMenu(); };
            NEW_GAME_PVC_BTN.onclick = () => { startGame('pvc', parseInt(BOARD_SIZE_SELECT.value)); closeOptionsMenu(); };
            PASS_TURN_BTN.onclick = () => handlePass();
            RESIGN_BTN.onclick = () => { if (!gameOver && window.confirm("Are you sure you want to resign?")) handleResign(); };
            GET_HINT_BTN.onclick = showHint;
            TOGGLE_COORDS_BTN.onclick = toggleCoordinates;
            BOARD_SIZE_SELECT.onchange = () => { const newSize = parseInt(BOARD_SIZE_SELECT.value); if (!gameOver && gameMode) { setMessage("Board size change will apply to the next new game."); } else { drawEmptyBoard(newSize); } };
            let resizeTimeout; window.onresize = () => { clearTimeout(resizeTimeout); resizeTimeout = setTimeout(drawBoard, 250); };
        }

        // --- Helper Functions ---
        function explainHint(move) {
            const explanations = {
                'A2': ' to secure territory on the lower left side and threaten Black\'s corner.',
                'B2': ' to establish a strong base on the left side.',
                'C3': ' to claim the corner territory.',
                // Add more explanations as needed
            };
            return explanations[move] || ' for strategic positioning.';
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, initializing Go board...');
            try {
                console.log('Loading settings...');
                loadSettings(); // Load settings on startup
                console.log('Settings loaded successfully');
                
                console.log('Setting up modal interactions...');
                setupModalInteractions();
                console.log('Modal interactions set up successfully');
                
                console.log('Setting up event listeners...');
                setupEventListeners();
                console.log('Event listeners set up successfully');
                
                console.log('Drawing empty board...');
                drawEmptyBoard(parseInt(BOARD_SIZE_SELECT.value));
                console.log('Empty board drawn successfully');
                
                console.log('Go board initialized successfully');
                console.log('Game started:', gameStarted);
                console.log('Current player:', currentPlayer);
            } catch (error) {
                console.error('Error during initialization:', error);
                console.error('Error stack:', error.stack);
                console.error('Error message:', error.message);
            }
        });

    </script>

</body>
</html>